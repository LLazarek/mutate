#+TITLE: mutate

A mutation framework for s-expression languages.

See the documentation for a full overview, and the example below for a teaser.

* Installation
: raco pkg install https://github.com/LLazarek/mutate

* Docs
: raco docs mutate

* An example
To define a mutation engine that does two things:
- swap the branches of if's
- negate all numeric constants
  
The same code is also in =full-example.rkt=.

#+BEGIN_SRC racket
#lang racket

(require syntax/parse
         mutate/define
         mutate/program)

(define-simple-mutator (if-swap stx)
  #:pattern ({~literal if} cond t e)
  #'(if cond e t))

(define-constant-mutator (constant-swap v)
  [(? number?) #:-> (- v)])

(define active-mutators (list if-swap
                              constant-swap))

(define combined-active-mutators (apply compose-mutators active-mutators))
(define mutate-expr (make-expr-mutator combined-active-mutators))
(define mutate-program (make-program-mutator mutate-expr))
(define mutate-program-syntax (syntax-only mutate-program))

(define program-to-mutate #'{(require "a.rkt")
                             (define x (if (yes?) 0 42))
                             (define y (if (negative? x)
                                           "negative!"
                                           (if (zero? x)
                                               "zero!"
                                               "positive!")))
                             (displayln y)})
(with-handlers ([mutation-index-exception? (Î» _ (displayln 'done!))])
  (for ([i (in-naturals)])
    (displayln (list i (syntax->datum (mutate-program-syntax program-to-mutate i))))))
; =>
;; (0 ((require a.rkt) (define x (if (yes?) 42 0)) (define y (if (negative? x) negative! (if (zero? x) zero! positive!))) (displayln y)))
;; (1 ((require a.rkt) (define x (if (yes?) 0 -42)) (define y (if (negative? x) negative! (if (zero? x) zero! positive!))) (displayln y)))
;; (2 ((require a.rkt) (define x (if (yes?) 0 42)) (define y (if (negative? x) (if (zero? x) zero! positive!) negative!)) (displayln y)))
;; (3 ((require a.rkt) (define x (if (yes?) 0 42)) (define y (if (negative? x) negative! (if (zero? x) positive! zero!))) (displayln y)))
;; done!
#+END_SRC

* Todos

** TODO Add a program mutator wrapper that handles `(module ...)` forms directly

